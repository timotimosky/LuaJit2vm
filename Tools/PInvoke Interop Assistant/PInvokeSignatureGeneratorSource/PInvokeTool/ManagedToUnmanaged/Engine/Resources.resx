<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="_Array" xml:space="preserve">
    <value>array</value>
  </data>
  <data name="_SafeArray" xml:space="preserve">
    <value>safe array</value>
  </data>
  <data name="_String" xml:space="preserve">
    <value>string</value>
  </data>
  <data name="_Structure" xml:space="preserve">
    <value>structure</value>
  </data>
  <data name="_Union" xml:space="preserve">
    <value>union</value>
  </data>
  <data name="Enum" xml:space="preserve">
    <value>enum '{0}'</value>
  </data>
  <data name="Error" xml:space="preserve">
    <value>error</value>
  </data>
  <data name="ERROR_ArraySizeNotAllowedForByref" xml:space="preserve">
    <value>SizeConst and SizeParamIndex cannot be used with byref array parameters.</value>
  </data>
  <data name="ERROR_ArraySizeParamIndexOutOfRange" xml:space="preserve">
    <value>The SizeParamIndex field value '{0}' is out of range. It should be a zero-based parameter index.</value>
  </data>
  <data name="ERROR_ArraySizeParamWrongType" xml:space="preserve">
    <value>The SizeParamIndex field value refers to a parameter of type '{0}'. Array size control parameter must be of an integral type.</value>
  </data>
  <data name="ERROR_ByValArrayInvalidLength" xml:space="preserve">
    <value>The SizeConst field of the MarshalAsAttribute must be positive for ByValArray arrays.</value>
  </data>
  <data name="ERROR_CustomMarshalerNotAllowedOnFields" xml:space="preserve">
    <value>Custom marshalers cannot be used on fields of structures.</value>
  </data>
  <data name="ERROR_CustomMarshalerNotAllowedOnValueTypes" xml:space="preserve">
    <value>Custom marshalers are only allowed on classes, strings, arrays, and boxed value types.</value>
  </data>
  <data name="ERROR_GenericTypesNotAllowed" xml:space="preserve">
    <value>Generic types cannot be marshaled.</value>
  </data>
  <data name="ERROR_HandlesNotPermittedAsArrayElements" xml:space="preserve">
    <value>SafeHandle and CriticalHandle are not allowed array element types.</value>
  </data>
  <data name="ERROR_InvalidManagedUnmanagedCombo" xml:space="preserve">
    <value>Invalid managed/unmanaged type combination, cannot marshal '{0}' as '{1}'. Using defaults.</value>
  </data>
  <data name="ERROR_InvalidUnmanagedSize" xml:space="preserve">
    <value>The size value '{0}' is invalid. It must be non-negative.</value>
  </data>
  <data name="ERROR_MarshalerHasNoGetInstance" xml:space="preserve">
    <value>Custom marshaler '{0}' does not implement a static GetInstance method that takes a single string parameter and returns an ICustomMarshaler.</value>
  </data>
  <data name="ERROR_MarshalerIsNotICustomMarshaler" xml:space="preserve">
    <value>Type '{0}' does not implement ICustomMarshaler and hence is not a custom marshaler.</value>
  </data>
  <data name="ERROR_MarshalingAllowedForCom" xml:space="preserve">
    <value>Marshaling of managed type '{0}' is allowed only for COM interop.</value>
  </data>
  <data name="ERROR_MisalignedReferenceTypeField" xml:space="preserve">
    <value>Reference type field '{0}' is not properly aligned. Its offset must be a multiple of pointer size on the target platform.</value>
  </data>
  <data name="ERROR_NoFieldOffsetInSequentialLayout" xml:space="preserve">
    <value>The field '{0}' is declared by a type with explicit layout but lacks the mandatory FieldOffsetAttribute.</value>
  </data>
  <data name="ERROR_NoNestedArrayMarshaling" xml:space="preserve">
    <value>There is no nested array marshaling support.</value>
  </data>
  <data name="ERROR_OverlappingReferenceTypeField" xml:space="preserve">
    <value>Reference type field '{0}' overlaps with another field '{1}'.</value>
  </data>
  <data name="ERROR_PInvokeIsNotStatic" xml:space="preserve">
    <value>The method is an instance method. All P/Invoke methods must be declared as static.</value>
  </data>
  <data name="ERROR_RecursiveStructureDeclaration" xml:space="preserve">
    <value>Structure recursively contains iself via field '{0}'.</value>
  </data>
  <data name="ERROR_StringBuilderFieldsDisallowed" xml:space="preserve">
    <value>StringBuilder fields cannot be marshaled. Use String instead.</value>
  </data>
  <data name="ERROR_TypeHasNoLayout" xml:space="preserve">
    <value>Type '{0}' cannot be marshaled because it has automatic layout. Use StructLayoutAttribute with either LayoutKind.Sequential or LayoutKind.Explicit.</value>
  </data>
  <data name="ERROR_UnexpectedEnumUnderlyingType" xml:space="preserve">
    <value>The underlying type '{0}' is illegal. It must be an integral type except for char.</value>
  </data>
  <data name="ERROR_UnmanagedPointersToRefType" xml:space="preserve">
    <value>Cannot use the unmanaged '*' pointer indirection on managed reference type '{0}'.</value>
  </data>
  <data name="ERROR_UnmanagedTypeRequiredForField" xml:space="preserve">
    <value>Invalid managed/unmanaged type combination, MarshalAsAttribute must be applied on this field.</value>
  </data>
  <data name="ERROR_UnsupportedAlignment" xml:space="preserve">
    <value>The pack value '{0}' is invalid. Valid values are 0, 1, 2, 4, 8, 16, 32, 64, and 128.</value>
  </data>
  <data name="ERROR_VariantReturnTypeNotSupported" xml:space="preserve">
    <value>VARIANT return type is not supported by interop. Use an 'out object' parameter instead.</value>
  </data>
  <data name="ERROR_VBByRefParamNotByRef" xml:space="preserve">
    <value>VBByRefStr can only be used in combination with in/out, by-reference managed-to-unmanaged strings.</value>
  </data>
  <data name="Field" xml:space="preserve">
    <value>field '{0}'</value>
  </data>
  <data name="Function" xml:space="preserve">
    <value>function '{0}'</value>
  </data>
  <data name="FunctionPointer" xml:space="preserve">
    <value>function pointer '{0}'</value>
  </data>
  <data name="Info" xml:space="preserve">
    <value>info</value>
  </data>
  <data name="INFO_ArraySizeDeterminedDynamically" xml:space="preserve">
    <value>Marshaler will marshal all elements of the actual array argument (determined at runtime).</value>
  </data>
  <data name="INFO_ArraySizeIsByParameter" xml:space="preserve">
    <value>The number of elements of the unmanaged array will be the value of parameter '{0}'.</value>
  </data>
  <data name="INFO_ArraySizeIsByParameterPlusConstant" xml:space="preserve">
    <value>The number of elements of the unmanaged array will be the value of parameter '{0}' plus {1}.</value>
  </data>
  <data name="INFO_ArraySizeIsConstant" xml:space="preserve">
    <value>Marshaler will marshal {0} elements of the unmanaged array.</value>
  </data>
  <data name="INFO_AsAnyMarshaling" xml:space="preserve">
    <value>The actual marshaling of AsAny will be determined at runtime, stack/structure layout may be inaccurate.</value>
  </data>
  <data name="INFO_AutoCharacterMarshaling" xml:space="preserve">
    <value>Parameter may be marshaled as ANSI character (8-bit) or Unicode character (16-bit) depending on the target platform.</value>
  </data>
  <data name="INFO_AutoStringMarshaling" xml:space="preserve">
    <value>Parameter may be marshaled as ANSI string (8-bit) or Unicode string (16-bit) depending on the target platform.</value>
  </data>
  <data name="INFO_BewarePrematureDelegateRelease" xml:space="preserve">
    <value>If the callback may occur after the unmanaged function has returned, the delegate must be kept alive using e.g. a static field to prevent premature unmanaged thunk release.</value>
  </data>
  <data name="INFO_BewareStringImmutability" xml:space="preserve">
    <value>Unmanaged function must not modify the string. StringBuilder should be used for string out or in/out parameters.</value>
  </data>
  <data name="INFO_BufferCallbackIn" xml:space="preserve">
    <value>The buffer containing the {0} will not be freed by the marshaler, it will be still owned by the calling function.</value>
  </data>
  <data name="INFO_BufferCallbackInOut" xml:space="preserve">
    <value>The buffer containing the {0} will be freed using CoTaskMemFree by the marshaler before the call and allocated using CoTaskMemAlloc by the marshaler after the call. The calling function must pass a pointer allocated using CoTaskMemAlloc and will own the returned buffer which is to be freed using CoTaskMemFree.</value>
  </data>
  <data name="INFO_BufferCallbackOut" xml:space="preserve">
    <value>The buffer containing the {0} will be allocated by the marshaler using CoTaskMemAlloc after the call. The calling function will own the returned buffer which is to be freed by CoTaskMemFree.</value>
  </data>
  <data name="INFO_BufferInOut" xml:space="preserve">
    <value>The buffer containing the {0} will be allocated by the marshaler using CoTaskMemAlloc before the call and freed by the marshaler using CoTaskMemFree after the call. If the function reallocates the buffer, it must use CoTaskMemAlloc and free the original buffer using CoTaskMemFree.</value>
  </data>
  <data name="INFO_BufferOut" xml:space="preserve">
    <value>The buffer containing the {0} must be allocated using CoTaskMemAlloc by the function because it will be freed using CoTaskMemFree by the marshaler after the call.</value>
  </data>
  <data name="INFO_BufferTemporaryIn" xml:space="preserve">
    <value>A temporary buffer containing the {0} will be allocated by the marshaler before the call and freed by the marshaler after the call.</value>
  </data>
  <data name="INFO_CustomMarshaledParameter" xml:space="preserve">
    <value>This parameter will be marshaled by custom marshaler implemented by type '{0}'.</value>
  </data>
  <data name="INFO_DefaultArrayAndRefTypeMarshaling" xml:space="preserve">
    <value>Arrays and formatted reference types marshal in only by default. OutAttribute or a combination of InAttribute and OutAttribute can be used to change the marshaling direction.</value>
  </data>
  <data name="INFO_DefaultStringBuilderMarshaling" xml:space="preserve">
    <value>StringBuilder marshals in/out by default. InAttribute or OutAttribute can be applied to optimize marshaling by omitting the other direction.</value>
  </data>
  <data name="INFO_FixedLengthStringInvalidLength" xml:space="preserve">
    <value>The SizeConst field of the MarshalAsAttribute must be positive for ByValTStr strings.</value>
  </data>
  <data name="INFO_InterfacePointerToRCWMarshaling" xml:space="preserve">
    <value>When a particular interface pointer enters the appdomain for the first time, a runtime callable wrapper (RCW) will be created. Call Marshal.ReleaseComObject or unload the appdomain to have the runtime explicitly Release the interface pointer.</value>
  </data>
  <data name="INFO_LayoutBlittableCallbackParameter" xml:space="preserve">
    <value>The managed type '{0}' is blittable and is used in a callback. Managed code will directly access the instance pointer passed from unmanaged code.</value>
  </data>
  <data name="INFO_LayoutBlittableParameter" xml:space="preserve">
    <value>The managed type '{0}' is blittable and may be pinned by the marshaler in which case a pointer to the managed instance will be passed to unmanaged code.</value>
  </data>
  <data name="INFO_LayoutDirectionBoth" xml:space="preserve">
    <value>Marshaler will marshal the value both when transitioning from managed to unmanaged and from unmanaged to managed. Changes made by the managed side will be visible in unmanaged and vice-versa.</value>
  </data>
  <data name="INFO_LayoutDirectionManagedToNative" xml:space="preserve">
    <value>Marshaler will only marshal the value when transitioning from managed to unmanaged. Changes made by the unmanaged side will not be seen in managed.</value>
  </data>
  <data name="INFO_LayoutDirectionNativeToManaged" xml:space="preserve">
    <value>Marshaler will only marshal the value when transitioning from unmanaged to managed. Changes made by the managed side will not be seen in unmanaged.</value>
  </data>
  <data name="INFO_LayoutNonBlittableCallbackParameter" xml:space="preserve">
    <value>The managed type '{0}' is non-blittable and a temporary buffer holding the managed view of the structure will be allocated by the marshaler.</value>
  </data>
  <data name="INFO_LayoutNonBlittableParameter" xml:space="preserve">
    <value>The managed type '{0}' is non-blittable and a temporary buffer holding the unmanaged view of the instance will be allocated by the marshaler.</value>
  </data>
  <data name="INFO_ManagedObjectToCCWMarshaling" xml:space="preserve">
    <value>When a particular managed object is marshaled to unmanaged for the first time, a COM callable wrapper (CCW) will be created. When the reference count to the CCW reaches zero, it will be destroyed and if there are no managed references to the object, it will become eligible for garbage collection.</value>
  </data>
  <data name="INFO_PointerIsCOMInterfacePtr" xml:space="preserve">
    <value>This is a COM interface pointer representing the '{0}' managed type.</value>
  </data>
  <data name="INFO_PossibleAltNameLookup" xml:space="preserve">
    <value>Platform invoke will also look for '{0}' if '{1}' is not found.</value>
  </data>
  <data name="INFO_PossibleAutoAltNameLookup" xml:space="preserve">
    <value>Platform invoke may also look for '{0}' or '{1}' depending on the target platform.</value>
  </data>
  <data name="INFO_SafeArrayOfVariantsWrapperUse" xml:space="preserve">
    <value>The actual element VARTYPE can be changed by wrapping the element in UnknownWrapper, DispatchWrapper, ErrorWrapper, CurrencyWrapper, or BStrWrapper (all in System.Runtime.InteropServices namespace). </value>
  </data>
  <data name="INFO_SafeArrayWillMarshalAs" xml:space="preserve">
    <value>Elements of the safe array will be of '{0}' type.</value>
  </data>
  <data name="INFO_SeeMscorlibTlbForInterface" xml:space="preserve">
    <value>See mscorlib.tlb for the full definition of the '{0}' interface type.</value>
  </data>
  <data name="INFO_StringBuilderRequiresInit" xml:space="preserve">
    <value>The managed parameter is of the StringBuilder type and has to be initialized with an appropriate capacity prior to the call.</value>
  </data>
  <data name="Interface" xml:space="preserve">
    <value>interface '{0}'</value>
  </data>
  <data name="Number" xml:space="preserve">
    <value>number {0}</value>
  </data>
  <data name="Parameter" xml:space="preserve">
    <value>parameter '{0}'</value>
  </data>
  <data name="ReturnValue" xml:space="preserve">
    <value>return value</value>
  </data>
  <data name="Structure" xml:space="preserve">
    <value>structure '{0}'</value>
  </data>
  <data name="Union" xml:space="preserve">
    <value>union '{0}'</value>
  </data>
  <data name="WARN_ArraySizeDefaultsToOne" xml:space="preserve">
    <value>Marshaler will marshal only one element of the unmanaged array. Use SizeConst and/or SizeParamIndex fields of MarshalAsAttribute.</value>
  </data>
  <data name="WARN_ArraySizesIgnored" xml:space="preserve">
    <value>The SizeConst and SizeParamIndex fields of MarshalAsAttribute will be ignored. Marshaler will always marshal all elements of the array which is passed from managed to unmanaged.</value>
  </data>
  <data name="WARN_ByValRefTypeMarkedOut" xml:space="preserve">
    <value>The OutAttribute has no effect on '{0}'. It is only useful on those by value reference-type parameters which are StringBuilders, arrays, or formatted reference types.</value>
  </data>
  <data name="WARN_ByValStringMarkedOut" xml:space="preserve">
    <value>The OutAttribute has no effect on a string which is passed by value. It will be always marshaled in only.</value>
  </data>
  <data name="WARN_ByValValueTypeMarkedOut" xml:space="preserve">
    <value>The OutAttribute has no effect on a value type which is passed by value. It will be always marshaled in only.</value>
  </data>
  <data name="WARN_InsufficientUnmanagedSize" xml:space="preserve">
    <value>The size value '{0}' is too small. The minimum unmanaged size of the type is '{1}'.</value>
  </data>
  <data name="WARN_LayoutBlittableMarkedIn" xml:space="preserve">
    <value>Although InAttribute is used, the argument may be marshaled out as well because '{0}' is blittable.</value>
  </data>
  <data name="WARN_LayoutBlittableMarkedOut" xml:space="preserve">
    <value>Although OutAttribute is used, the the argument may be marshaled in as well because '{0}' is blittable.</value>
  </data>
  <data name="WARN_MarshalerTypeNotFound" xml:space="preserve">
    <value>Could not find custom marshaler type '{0}'.</value>
  </data>
  <data name="WARN_NonSpecificDelegateUsed" xml:space="preserve">
    <value>Unable to determine parameters and return type for the function pointer parameter type '{0}'. Use a specific delegate type if possible.</value>
  </data>
  <data name="WARN_NoPackEffectOnExplicitLayout" xml:space="preserve">
    <value>The Pack field has no effect when LayoutKind is not LayoutKind.Sequential.</value>
  </data>
  <data name="WARN_NormalizedStructure" xml:space="preserve">
    <value>Type '{0}' can be considered as '{1}' by the marshaler on some versions of the runtime. The MarshalAsAttribute should be avoided.</value>
  </data>
  <data name="WARN_PInvokeIsPublic" xml:space="preserve">
    <value>The method is public. P/Invoke methods should be declared with non-public visibility for security reasons.</value>
  </data>
  <data name="WARN_VarargIsNotCdecl" xml:space="preserve">
    <value>The method is declared with vararg but the calling convention is '{0}'. It should be 'Cdecl'.</value>
  </data>
  <data name="Warning" xml:space="preserve">
    <value>warning</value>
  </data>
</root>